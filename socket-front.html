<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css">
    <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
</head>

<body>
    <div id="search-bar"></div>
    <button id="mic"><i class="fas fa-microphone"></i></button>
    <div id="hits"></div>
</body>

<script src="http://localhost:8080/socket.io/socket.io.js"></script>

<script>

    var socket = io.connect("http://localhost:8080/");

    socket.on("connect", function() {
        // Do stuff when we connect to the server
        console.log("connected");
    });
    
    let myStream;
    let inputPoint;
    let scriptProcessor;

    const search = instantsearch({
        appId: 'latency',
        apiKey: '6be0576ff61c053d5f9a3225e2a90f76',
        indexName: 'instant_search',
        routing: true
    });

    search.addWidget(
        instantsearch.widgets.hits({
            container: '#hits',
            templates: {
                empty: 'No results',
                item: '<em>Hit {{objectID}}</em>: {{{_highlightResult.name.value}}}'
            }
        })
    );

    search.addWidget(
        instantsearch.widgets.searchBox({
            container: '#search-bar',
            placeholder: 'Search for products',
        })
    );

    search.addWidget({
        init: function(initOptions) {
            const micBtn = document.querySelector('#mic');

            /*** Google Chrome API ***/
            if (window.webkitSpeechRecognition !== undefined) {
                console.log("Chrome API is working");
                var recognition = new webkitSpeechRecognition();

                recognition.interimResults = true;

                recognition.onresult = function(event) { 
                    console.log(event.results[0][0]);
                    let query = event.results[0][0].transcript;
                    initOptions.helper.setQuery(query).search(); //Set the query and search
                    micBtn.innerHTML = '<i class="fas fa-microphone"></i>';    
                }
            } else {
                console.log("Speech recognition Chrome API not supported");
                
                /*** GCP Speech-To-Text API ***/
                var constraints = { 
                    audio: {
                        mandatory: {
                            googEchoCancellation: 'false',
                            googAutoGainControl: 'false',
                            googNoiseSuppression: 'false',
                            googHighpassFilter: 'false',
                        },
                    }
                };

                socket.on('dataFromGCP', (data) => { 
                    console.log("dataFromGCP", data);
                    let query = data;
                    initOptions.helper.setQuery(query).search(); //Set the query and search
                });
            }
            

            //Start/Stop mic on click
            micBtn.addEventListener('click', function(e){
                if(myStream){
                    //Stopping the mic
                    myStream.getAudioTracks()[0].stop();
                    myStream = null;
                    scriptProcessor.removeEventListener('audioprocess', streamAudioData);
                    micBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                    socket.emit("endStream", {});
                }else{
                    //Starting the mic

                    /*** Chrome API ***/
                    if (window.webkitSpeechRecognition !== undefined) {
                        recognition.start(); 
                    }else{
                        /*** GCP Speech-To-Text API ***/
                        navigator.mediaDevices.getUserMedia(constraints)
                            .then((stream) => {
                                startRecording(stream);
                            })
                            .catch(function(err) { console.log(err.name + ": " + err.message); }); // always check for errors at the end.

                        micBtn.innerHTML = '<i class="fas fa-dot-circle" style="color: red;"></i>';
                    }
                }
            })
        },
    });

    search.start();


function startRecording(stream) {

    socket.emit('startStream', {});
    
    var audioContext = audioContext || new AudioContext();
    if (!audioContext) {
        return;
    }
    myStream = stream;
    
    inputPoint = audioContext.createGain();
    const microphone = audioContext.createMediaStreamSource(myStream);
    const analyser = audioContext.createAnalyser();
    scriptProcessor = inputPoint.context.createScriptProcessor(2048, 1, 1);

    microphone.connect(inputPoint);
    inputPoint.connect(analyser);
    inputPoint.connect(scriptProcessor);
    scriptProcessor.connect(inputPoint.context.destination);
    scriptProcessor.addEventListener('audioprocess', streamAudioData);
}

function streamAudioData(e){
    const float32Samples = e.inputBuffer.getChannelData(0);

    socket.emit("audiodata", downsampleBuffer(float32Samples, 44100, 16000));
}

function downsampleBuffer(buffer, sampleRate, outSampleRate) {
    if (outSampleRate == sampleRate) {
        return buffer;
    }
    if (outSampleRate > sampleRate) {
        throw "downsampling rate show be smaller than original sample rate";
    }
    var sampleRateRatio = sampleRate / outSampleRate;
    var newLength = Math.round(buffer.length / sampleRateRatio);
    var result = new Int16Array(newLength);
    var offsetResult = 0;
    var offsetBuffer = 0;
    while (offsetResult < result.length) {
        var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        var accum = 0, count = 0;
        for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
            accum += buffer[i];
            count++;
        }

        result[offsetResult] = Math.min(1, accum / count)*0x7FFF;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
    }
    return result.buffer;
}

</script>
</html>